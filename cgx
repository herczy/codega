#!/usr/bin/env python

# Check if we're developing
try:
    import codega

except ImportError:
    import sys, os.path
    sys.path.append(os.path.dirname(__file__))

# MARK -- this comment is important, cgx pack will copy-paste the code below this
import sys
import optparse

from codega.rsclocator import FileResourceLocator
from codega.config import Config
from codega.generator import GeneratorBase
from codega.context import Context

#
# Helper functions
#

def load_generator(config, module, clsname):
    mod = config.locator.import_module(module)
    gen = getattr(mod, clsname)

    if isinstance(gen, GeneratorBase):
        return gen

    if issubclass(gen, GeneratorBase):
        return gen()

    raise ImportError("%s:%s is not a generator class or instance" % (module, clsname))

def build_config(source, parser, target, generator):
    from lxml import etree

    def make_text_node(tag, text):
        element = etree.Element(tag)
        element.text = text
        return element

    xml_paths = etree.Element('paths')
    xml_paths.append(make_text_node('target', '.'))
    xml_paths.append(make_text_node('path', '.'))

    xml_source = etree.Element('source')
    xml_source.append(make_text_node('name', 'source'))
    xml_source.append(make_text_node('filename', source))
    if parser is not None:
        xml_source.append(make_text_node('parser', parser))

    xml_target = etree.Element('target')
    xml_target.append(make_text_node('source', 'source'))
    xml_target.append(make_text_node('generator', generator))
    xml_target.append(make_text_node('target', target))

    xml = etree.Element('config')
    xml.attrib['version'] = '1.0'
    xml.append(xml_paths)
    xml.append(xml_source)
    xml.append(xml_target)

    rsc = FileResourceLocator([ '.' ])
    return Config(xml, system_locator = rsc)

def build_target(config, target):
    generator = load_generator(config, target.module, target.gentype)
    context = Context(config, target.sourceref, target)
    destination = sys.stdout if target.target == 'sys.stdout' else config.locator.open_writable_resource(target.target)

    generator.validate(target.sourceref.data, context)
    destination.write(generator.generate(target.sourceref.data, context))
    destination.close()

#
# Commands
#

def command_help(argv):
    '''Display command list'''

    global commands, command_names

    def _(h):
        print >>sys.stderr, h

    _('Codega run-time script')
    _('')
    _('Commands supported:')
    for cmd in command_names:
        fun = commands[cmd]
        _('  % -15s  %s' % (cmd, fun.__doc__.strip().split('\n', 1)[0]))

def command_make(argv):
    '''Build codega targets listed in the make file'''

    parser = optparse.OptionParser(usage = '%prog <options>')
    parser.add_option('-c', '--config',  default = 'codega.xml',
                      help = 'Specify config file (default: %default)')
    parser.add_option('-t', '--target', default = [], action = 'append',
                      help = 'Specify targets (default: all)')
    parser.add_option('-f', '--force', default = False, action = 'store_true',
                      help = 'Force rebuild')
    parser.add_option('-d', '--debug', default = False, action = 'store_true',
                      help = 'Produce debug output')
    opts, args = parser.parse_args(argv)

    # Load configuration file
    config = Config.load(opts.config)

    if opts.force:
        build_list = list(config.targets)

    else:
        build_list = list(config.find_need_rebuild())

    for target in build_list:
        try:
            build_target(config, target)

        except Exception, e:
            if opts.debug:
                raise

            print >>sys.stderr, "Error: %s" % e

def command_build(argv):
    '''Build the source with specified generator'''

    parser = optparse.OptionParser(usage = '%prog <options>')
    parser.add_option('-s', '--source', default = None,
                      help = 'Specify the source file')
    parser.add_option('-p', '--parser', default = 'codega.source:XmlSource',
                      help = 'Specify the parser in <module>:<source class> format (default: %default)')
    parser.add_option('-t', '--target', default = 'sys.stdout',
                      help = 'Specify the target file (default: sys.stdout)')
    parser.add_option('-g', '--generator', default = None,
                      help = 'Specify the generator in <module>:<source class> format')
    parser.add_option('-d', '--debug', default = False, action = 'store_true',
                      help = 'Produce debug output')
    opts, args = parser.parse_args(argv)

    if not opts.source:
        print >>sys.stderr, 'Missing source'
        exit(-1)

    if not opts.generator:
        print >>sys.stderr, 'Missing generator'
        exit(-1)

    config = build_config(opts.source, opts.parser, opts.target, opts.generator)

    try:
        target = config.targets[0]
        build_target(config, target)

    except Exception, e:
        if opts.debug:
            raise

        print >>sys.stderr, "Error: %s" % e

def command_pack(argv):
    '''Create a script containing the compressed codega module and the main script'''

    import os
    import os.path
    import sys
    import stat
    import time

    from hashlib import sha256
    from tarfile import TarFile
    from base64 import b64encode

    try:
        from cStringIO import StringIO

    except ImportError:
        from StringIO import StringIO

    import codega

    current_dir = os.path.dirname(__file__)
    def create_compressed_script(target):
        '''Create a script containing the compressed codega module and the main script

        Arguments:
        target -- Target file object
        '''

        def exclude_files(filename):
            return (filename[-4:] == '.pyc' or os.path.basename(filename)[0] == '.')

        def compress(path):
            output = StringIO()
            tar = TarFile.open(fileobj = output, mode = 'w:bz2')
            tar.add(path, arcname = 'codega', exclude = exclude_files)
            tar.close()
            return output.getvalue()

        def checksum(data):
            return sha256(data).hexdigest()

        def split_data(data, line_width = 80):
            enc = b64encode(data)
            res = []
            while enc:
                line = '#>>' + enc[:line_width] + '<<'
                enc = enc[line_width:]
                res.append(line)

            return '\n'.join(res)

        def load_main_code():
            '''Load cgmake code'''

            cgmake = []
            start = False

            for i in open(__file__):
                i = i.rstrip()

                if i[:6] == '# MARK':
                    start = True
                    continue

                if not start:
                    continue

                cgmake.append(i)

            return '\n'.join(cgmake)

        data = compress(os.path.dirname(codega.__file__))
        checksum = checksum(data)
        split = split_data(data)
        main_code = load_main_code()

        print >>target, '''#!/usr/bin/env python

import os
import os.path
import tarfile
import sys
import base64

outdir = '.codega-%(checksum)s'
outdir = os.path.join(os.path.dirname(__file__), outdir)

def check_decompress():
    global outdir

    try:
        from cStringIO import StringIO

    except ImportError:
        from StringIO import StringIO

    if os.path.isdir(outdir) and os.path.isdir(os.path.join(outdir, 'codega')):
        return

    if not os.path.isdir(outdir):
        if os.path.exists(outdir):
            raise Exception("%%s exists but is not a directory" %% outdir)

        data = ''.join(map(lambda l: l[3:-3], filter(lambda l: l[:3] == '#>>' and l[-3:] == '<<\\n', open(__file__))))
        data = base64.b64decode(data)

        os.mkdir(outdir)
        inobj = StringIO(data)
        tarfile.open(fileobj = inobj, mode = 'r:*').extractall(path = outdir)

sys.path.insert(0, outdir)
check_decompress()

%(main_code)s

%(split)s
''' % locals()

    if len(argv) != 2:
        print >>sys.stderr, "Usage: %s pack <output>" % sys.argv[0]
        exit(1)

    out = open(argv[1], 'w')
    create_compressed_script(out)
    out.close()
    os.chmod(argv[1], 0755)

command_names = [ 'help', 'build', 'make', 'pack' ]
commands = dict((fun, globals()['command_%s' % fun]) for fun in command_names)

if __name__ == '__main__':
    cmd = sys.argv[1] if len(sys.argv) > 1 else 'help'
    commands[cmd](sys.argv[1:])
